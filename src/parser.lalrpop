use crate::token::Token;
use crate::lexer;
use crate::ast::*;
use crate::symbol::*;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, &'static str>>);

pub Module: Module = Located<Commented<ModuleInner>>;

pub ModuleInner: ModuleInner = {
  "module" <name:UpperQualifiedIdent>
  <exports:("(" <SepBy<DeclarationRef, ",">> ")")?>
  "where" <guts:ModuleGuts>
      => ModuleInner { name, exports, imports: guts.0, declarations: guts.1 }
};

ModuleGuts: (Vec<Import>, Vec<Declaration>) = {
  () => (vec![], vec![]),
  LayoutStart <imports:SepBy<Import, LayoutSep>>
    <declarations:SepBy<Declaration, LayoutSep>> LayoutEnd =>
    (imports, declarations),
};

pub Import: Import = Located<ImportInner>;

pub ImportInner: ImportInner = {
  "import" <module:UpperQualifiedIdent>
    <kind:ImportDeclarationKind>
    <alias:("as" <UpperQualifiedIdent>)?> =>
    ImportInner{module,kind,alias}
};

pub ImportDeclarationKind: ImportDeclarationKind = {
  () => ImportDeclarationKind::Implicit,
  "(" <SepBy<DeclarationRef, ",">> ")" => ImportDeclarationKind::Explicit(<>),
  "hiding" "(" <SepBy<DeclarationRef, ",">> ")" => ImportDeclarationKind::Hiding(<>),
};

LowerIdent: Symbol = {
  lower_ident => Symbol::new(<>)
};

LowerQualifiedIdent: QualifiedName = {
  LowerIdent => QualifiedName(<>),
  lower_qualified_ident => QualifiedName(Symbol::new(<>)),
};

UpperIdent: Symbol = {
  upper_ident => Symbol::new(<>)
};

UpperQualifiedIdent: QualifiedName = {
  UpperIdent => QualifiedName(<>),
  upper_qualified_ident => QualifiedName(Symbol::new(<>)),
};


Located<T>: Located<T> = {
  <start:@L> <v:T> <end:@R> => Located(SourceSpan{start, end}, v)
};

MaybeLayoutBlock<T>: Vec<T> = {
  LayoutBlock<T>? => <>.unwrap_or_else(|| vec![])
}

LayoutBlock<T>: Vec<T> = {
  LayoutStart <v:SepBy<T, LayoutSep>> LayoutEnd => v
}

DeclarationRef: DeclarationRef = Located<DeclarationRefKind>;

DeclarationRefKind: DeclarationRefKind = {
  "class" <name:UpperIdent> => DeclarationRefKind::TypeClass{name},
  "type" "(" <name:Operator> ")" => DeclarationRefKind::TypeOp{name},
  <name:UpperIdent> <constructors:DeclarationRefConstructors?> =>
    DeclarationRefKind::Type{name,constructors},
  <name:LowerIdent> => DeclarationRefKind::Value{name},
  "(" <name:Operator> ")" => DeclarationRefKind::ValueOp{name},
  "module" <name:UpperQualifiedIdent> => DeclarationRefKind::Module{name},
};

DeclarationRefConstructors: DeclarationRefConstructors = {
  "(" ".." ")" => DeclarationRefConstructors::All,
  "(" <SepBy<UpperIdent, ",">> ")" => DeclarationRefConstructors::Some(<>),
};

Declaration: Declaration = Located<Commented<DeclarationKind>>;

DeclarationKind: DeclarationKind = {
  ValueDeclaration => DeclarationKind::ValueDeclaration(<>),
  TypeDeclaration => DeclarationKind::TypeSignature(<>),
  "type" <name:UpperIdent> <params:TypeParameter*> "=" <body:Type> => DeclarationKind::TypeSynonym{name, params, body},
  "foreign" "import" <name:LowerIdent> "::" <type_:Type> => DeclarationKind::ForeignValue{name, type_},
  ClassDeclaration => DeclarationKind::Class(<>),
  InstanceDeclaration => DeclarationKind::Instance(<>),
}

ClassDeclaration: TypeClassDeclaration = {
  "class"
    <constraints:(<TypeClassConstraints> "=>")?>
    <name:UpperIdent> <params:TypeParameter*>
    <methods:("where" <MaybeLayoutBlock<TypeDeclaration>>)?> =>
    TypeClassDeclaration {
      constraints: vec![],
      name,
      params,
      methods: methods.unwrap_or_else(|| vec![]),
    }
};

InstanceDeclaration: InstanceDeclaration = {
  "instance"
    <instance_name:(<LowerIdent> "::")?>
    <constraints:(<TypeClassConstraints> "=>")?>
    <class:UpperQualifiedIdent>
    <args:Located<AtomicType>*>
    <body:("where" <MaybeLayoutBlock<ValueDeclaration>>)?> =>
      InstanceDeclaration {
        constraints: constraints.unwrap_or_else(|| vec![]),
        instance_name,
        class,
        args,
        body: body.unwrap_or_else(|| vec![]),
      }
};

TypeClassConstraints: Vec<Type> = {
// TODO:  <Located<Constraint>> => vec![<>],
  "(" <SepBy<Located<Constraint>, ",">> ")"
};

TypeParameter: (Symbol, Type) = {
  <start:@L> <name:LowerIdent> <end:@R> =>
    (name, Located(SourceSpan{start, end}, TypeKind::TypeConstructor(QualifiedName(Symbol::new("Prim.Type".into())))))
};

ValueDeclaration: ValueDeclaration = {
  <ident:LowerIdent> <params:Pat*> "=" <expr:Expr> => ValueDeclaration{ident, params, expr: vec![GuardedExpr{guards: vec![], expr}]}
}

TypeDeclaration: TypeDeclarationData = {
  <ident:LowerIdent> "::" <type_:Type> => TypeDeclarationData::new(ident,type_)
}

pub Expr: Expr = Located<ExprKind>;

ExprKind: ExprKind = LambdaExpr<InfixExpr<ApplyExpr<AccessorExpr<PrimaryExpr>>>>;

LambdaExpr<Next>: ExprKind = {
  Next,
  "\\" <params:Located<PrimaryPat>+> "->" <body:Located<Next>> => ExprKind::Lam(params, Box::new(body)),
};

InfixExpr<Next>: ExprKind = {
  Next,
  <first:Located<Next>> <rest:( <Operator> <Located<Next>> )+> => ExprKind::Infix(Box::new(first), rest),
};

Operator: Symbol = {
  operator => Symbol::new(<>)
};

ApplyExpr<Next>: ExprKind = {
  Next,
  <f:Located<Next>> <args:Located<Next>+> => ExprKind::App(Box::new(f), args),
};

AccessorExpr<Next>: ExprKind = {
  Next,
  <obj:Located<AccessorExpr<Next>>> "." <label:Label> => ExprKind::Accessor(Box::new(obj), label),
};

PrimaryExpr: ExprKind = {
  Literal<Expr, RecordShortcutExpr> => ExprKind::Literal(<>),
  LowerQualifiedIdent => ExprKind::Var(<>),
  "(" <ExprKind> ")" => <>,
}

pub Pat: Pat = Located<PatKind>;

PatKind: PatKind = InfixPat<PrimaryPat>;

InfixPat<Next>: PatKind = {
  Next,
  <first:Located<Next>> <rest:( <Operator> <Located<Next>> )+> => PatKind::Infix(Box::new(first), rest),
};

PrimaryPat: PatKind = {
  Literal<Pat, RecordShortcutPat> => PatKind::Literal(<>),
  LowerIdent => PatKind::Var(<>),
  "(" <PatKind> ")" => <>,
  "_" => PatKind::Wildcard,
}

Literal<T, RecordShortcut>: Literal<T> = {
  int => Literal::Integer(<>),
  // float => Literal::Float(<>),
  string => Literal::String(<>),
  char => Literal::Char(<>),
  "true" => Literal::Boolean(true),
  "false" => Literal::Boolean(false),
  "[" <SepBy<T, ",">> "]" => Literal::Array(<>),
  "{" <SepBy<RecordField<T, RecordShortcut>, ",">> "}" => Literal::Object(<>),
}

RecordField<T, RecordShortcut>: (Symbol, T) = {
  <label:Label> ":" <expr:T> => (label, expr),
  RecordShortcut
};

RecordShortcutExpr: (Symbol, Expr) = {
  // Note: string literal labels not allowed here, because they may not be a valid variable name
  <start:@L> <label:lower_ident> <end:@R> => {
    let label = Symbol::new(label);
    (
      label.clone(),
      Located(SourceSpan{start, end}, ExprKind::Var(QualifiedName(label)))
    )
  }
};

RecordShortcutPat: (Symbol, Pat) = {
  // Note: string literal labels not allowed here, because they may not be a valid variable name
  <start:@L> <label:lower_ident> <end:@R> => {
    let label = Symbol::new(label);
    (
      label.clone(),
      Located(SourceSpan{start, end}, PatKind::Var(label))
    )
  }
};


// TODO: extract the comments
Commented<T>: Commented<T> = {
  <v:T> => Commented(vec![], v)
};

SepBy<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

SepBy1<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

OptionalList<T, X>: Vec<T> = {
  X? => <>.unwrap_or_else(|| vec![]),
};

////////////////////////////////////////////////////////////////////////////////
// Type
////////////////////////////////////////////////////////////////////////////////

pub Type = Located<Type1>;

Type1: TypeKind = {
  // TODO: At first I put the forall in AtomicType, but it resulted in parse conflicts.
  // Here it seems to work. I have no idea why.
  "forall" <vars:OneOrMore<ForallVar>> "." <body:Type> =>
    TypeKind::ForAll{vars,body:Box::new(body),skolem_scope:None},
  <constraint:Constraint> "=>" <body:Type> =>
    TypeKind::Constrained{constraint:Box::new(constraint),body:Box::new(body)},
  <arg:Located<TypeApp>> "->" <result:Type> =>
    TypeKind::FunctionType(Box::new(arg), Box::new(result)),
  TypeApp
}

Constraint: Constraint = {
  <class:UpperQualifiedIdent> <type_args:Located<AtomicType>*> =>
    Constraint { class, type_args }
};

TypeApp: TypeKind = {
  <l:Located<TypeApp>> <r:Located<AtomicType>> => TypeKind::TypeApp(Box::new(l), Box::new(r)),
  AtomicType
};

TypeConstructor: TypeKind = {
  UpperQualifiedIdent => TypeKind::TypeConstructor(<>),
};

AtomicType: TypeKind = {
  LowerIdent => TypeKind::Var(<>),
  string=>TypeKind::TypeLevelString(<>),
  int=>TypeKind::TypeLevelInt(<>.into()),
  "_" => TypeKind::Wildcard(WildcardKind::Unnamed),
  // TODO: hole

  TypeConstructor,
  "(" <fields:SepBy<RowField, ",">> <rest:RowRest?> ")" => TypeKind::Row{fields,rest},
  <record_start:@L> "{" <record_end:@R>
  <row_start:@L> <fields:SepBy<RowField, ",">> <rest:RowRest?> <row_end:@R> "}" =>
    TypeKind::TypeApp(
      Box::new(
        Located(SourceSpan{start: record_start, end: record_end}, 
          TypeKind::TypeConstructor(QualifiedName(Symbol::new("Prim.Record".to_string()))))),
      Box::new(
        Located(SourceSpan{start: row_start, end: row_end}, 
          TypeKind::Row{fields,rest}))
    ),
  "(" <v:Type> ")" => TypeKind::Parens(Box::new(v)),
};

RowField: (Symbol, Type) = {
  <label:Label> "::" <ty:Type> => (label, ty)
}

RowRest: Box<Type> = {
  "|" <ty:Type> => Box::new(ty)
}

/// A record field label
Label: Symbol = {
  LowerIdent,
  string => Symbol::new(<>),
};

ForallVar: (Symbol, Option<Box<Type>>) = {
  <name:LowerIdent> => (name, None),
  "(" <name:LowerIdent> "::" <kind:Type> ")" => (name, Some(Box::new(kind))),
};

OneOrMore<T>: Vec<T> = {
  <xs:T*> <x:T> => {
    let mut xs = xs;
    xs.push(x);
    xs
  }
}

extern {
  type Location = usize;
  type Error = lexer::Error;

  enum Token {
    int => Token::IntegerLiteral(<i32>),
    string => Token::StringLiteral(<String>),
    char => Token::CharLiteral(<char>),
    lower_ident => Token::LowerIdentifier(<String>),
    lower_qualified_ident => Token::QualifiedLowerIdentifier(<String>),
    upper_ident => Token::UpperIdentifier(<String>),
    upper_qualified_ident => Token::QualifiedUpperIdentifier(<String>),

    // Layout
    LayoutStart => Token::LayoutStart,
    LayoutSep => Token::LayoutSep,
    LayoutEnd => Token::LayoutEnd,

    // Operators
    "(" => Token::LeftParen,
    ")" => Token::RightParen,
    "{" => Token::LeftBrace,
    "}" => Token::RightBrace,
    "[" => Token::LeftBracket,
    "]" => Token::RightBracket,
    "`" => Token::Backtick,
    "=" => Token::Equal,
    "|" => Token::Pipe,
    "," => Token::Comma,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "." => Token::Dot,
    "\\" => Token::Backslash,

    "->" => Token::Arrow,
    "=>" => Token::FatArrow,
    "::" => Token::TypeOf,
    "<-" => Token::Bind,
    ".." => Token::DotDot,

    operator => Token::Operator(<String>),

    // Keywords
    "if" => Token::If,
    "then" => Token::Then,
    "else" => Token::Else,
    "ado" => Token::Ado,
    "do" => Token::Do,
    "case" => Token::Case,
    "of" => Token::Of,
    "let" => Token::Let,
    "in" => Token::In,
    "where" => Token::Where,
    "instance" => Token::Instance,
    "module" => Token::Module,
    "import" => Token::Import,
    "forall" => Token::Forall,
    "true" => Token::True,
    "false" => Token::False,
    "class" => Token::Class,
    "type" => Token::Type,
    "as" => Token::As,
    "hiding" => Token::Hiding,
    "foreign" => Token::Foreign,
    "_" => Token::Wildcard,
  }
}
