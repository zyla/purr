use crate::token::Token;
use crate::lexer;
use crate::ast::*;
use crate::symbol::*;
use lalrpop_util::ErrorRecovery;
use lalrpop_util::ParseError;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, &'static str>>);

pub Module: Module = Located<Commented<ModuleInner>>;

ModuleInner: ModuleInner = {
  "module" <name:UpperQualifiedIdent>
  <exports:("(" <SepBy<DeclarationRef, ",">> ")")?>
  "where" <guts:ModuleGuts>
      => ModuleInner { name, exports, imports: guts.0, declarations: guts.1 }
};

ModuleGuts: (Vec<Import>, Vec<Declaration>) = {
  () => (vec![], vec![]),
  LayoutStart <imports:SepBy<Import, LayoutSep>>
    <declarations:SepBy<Declaration, LayoutSep>> LayoutEnd =>
    (imports, declarations),
};

Import: Import = Located<ImportInner>;

ImportInner: ImportInner = {
  "import" <module:UpperQualifiedIdent>
    <kind:ImportDeclarationKind>
    <alias:("as" <UpperQualifiedIdent>)?> =>
    ImportInner{module,kind,alias}
};

ImportDeclarationKind: ImportDeclarationKind = {
  () => ImportDeclarationKind::Implicit,
  "(" <SepBy<DeclarationRef, ",">> ")" => ImportDeclarationKind::Explicit(<>),
  "hiding" "(" <SepBy<DeclarationRef, ",">> ")" => ImportDeclarationKind::Hiding(<>),
};

LowerIdent: Symbol = {
  lower_ident => Symbol::new(<>)
};

LowerQualifiedIdent: QualifiedName = {
  LowerIdent => QualifiedName(<>),
  lower_qualified_ident => QualifiedName(Symbol::new(<>)),
};

UpperIdent: Symbol = {
  upper_ident => Symbol::new(<>)
};

UpperQualifiedIdent: QualifiedName = {
  UpperIdent => QualifiedName(<>),
  upper_qualified_ident => QualifiedName(Symbol::new(<>)),
};


Located<T>: Located<T> = {
  <start:@L> <v:T> <end:@R> => Located(SourceSpan{start, end}, v)
};

MaybeLayoutBlock<T>: Vec<T> = {
  LayoutBlock<T>? => <>.unwrap_or_else(|| vec![])
}

LayoutBlock<T>: Vec<T> = {
  LayoutStart <v:SepBy<T, LayoutSep>> LayoutEnd => v
}

DeclarationRef: DeclarationRef = Located<DeclarationRefKind>;

DeclarationRefKind: DeclarationRefKind = {
  "class" <name:UpperIdent> => DeclarationRefKind::TypeClass{name},
  "type" "(" <name:TypeOperator> ")" => DeclarationRefKind::TypeOp{name},
  <name:UpperIdent> <constructors:DeclarationRefConstructors?> =>
    DeclarationRefKind::Type{name,constructors},
  <name:LowerIdent> => DeclarationRefKind::Value{name},
  "(" <name:Operator> ")" => DeclarationRefKind::ValueOp{name},
  "module" <name:UpperQualifiedIdent> => DeclarationRefKind::Module{name},
};

TypeOperator: Symbol = {
  Operator,
  "->" => Symbol::new("->".into()),
};

DeclarationRefConstructors: DeclarationRefConstructors = {
  "(" ".." ")" => DeclarationRefConstructors::All,
  "(" <SepBy<UpperIdent, ",">> ")" => DeclarationRefConstructors::Some(<>),
};

Declaration: Declaration = Located<Commented<DeclarationKind>>;

DeclarationKind: DeclarationKind = {
  ValueDeclaration => DeclarationKind::ValueDeclaration(<>),
  TypeDeclaration => DeclarationKind::TypeSignature(<>),
  "type" <name:UpperIdent> <params:TypeParameter*> "=" <body:Type> => DeclarationKind::TypeSynonym{name, params, body},
  "foreign" "import" <name:LowerIdent> "::" <type_:Type> => DeclarationKind::ForeignValue{name, type_},
  ClassDeclaration => DeclarationKind::Class(<>),
  InstanceChain => DeclarationKind::InstanceChain(<>),
  DataDeclaration,
}

LetDeclaration: Declaration = Located<Commented<LetDeclarationKind>>;

LetDeclarationKind: DeclarationKind = {
  ValueDeclaration => DeclarationKind::ValueDeclaration(<>),
  TypeDeclaration => DeclarationKind::TypeSignature(<>),
  <pat:AsPat<ExprV<"let_pat">>> "=" <expr:Expr> => DeclarationKind::Destructuring { pat, expr },
}

DataDeclaration: DeclarationKind = {
  <type_:DataDeclType> <name:UpperIdent>
    <params:TypeParameter*>
    <kind:("::" <Type>)?>
    <constructors:("=" <SepBy1<DataConstructorDeclaration, "|">>)?> =>
    DeclarationKind::Data {
      type_,
      name,
      params,
      kind,
      constructors: constructors.unwrap_or_else(|| vec![]),
    }
};

DataConstructorDeclaration = Located<Commented<DataConstructorDeclarationData>>;

DataConstructorDeclarationData: DataConstructorDeclarationData = {
  <name:UpperIdent> <fields:Located<AtomicType>*> => DataConstructorDeclarationData{ name, fields }
};

DataDeclType: DataDeclType = {
  "data" => DataDeclType::Data,
  "foreign" "import" "data" => DataDeclType::ForeignData,
  "newtype" => DataDeclType::Newtype,
};

ClassDeclaration: TypeClassDeclaration = {
  "class"
    <constraints:(<TypeClassConstraints> "<=")?>
    <head:Located<Constraint>>
    <methods:("where" <MaybeLayoutBlock<TypeDeclaration>>)?> =>? {
      let (name, params) = super::constraint_to_class_head(head)
        .ok_or_else(|| ParseError::User {
          // TODO: make it not a lexer error
          error: lexer::Error("Invalid instance head".into())
        })?;
      Ok(TypeClassDeclaration {
        constraints: constraints.unwrap_or_else(|| vec![]),
        name,
        params,
        methods: methods.unwrap_or_else(|| vec![]),
      })
    }
};

InstanceChain: Vec<InstanceDeclaration> = SepBy1<InstanceDeclaration, "else">;

InstanceDeclaration: InstanceDeclaration = {
  <instance_type:InstanceType>
  "instance"
    <instance_name:(<LowerIdent> "::")?>
    <constraints:(<TypeClassConstraints> "=>")?>
    <head:Located<Constraint>>
    <body:("where" <MaybeLayoutBlock<ValueDeclaration>>)?> =>? {
      let (class, args) = super::constraint_to_instance_head(head)
        .ok_or_else(|| ParseError::User {
          // TODO: make it not a lexer error
          error: lexer::Error("Invalid instance head".into())
        })?;
      Ok(InstanceDeclaration {
        constraints: constraints.unwrap_or_else(|| vec![]),
        instance_type,
        instance_name,
        class,
        args,
        body: body.unwrap_or_else(|| vec![]),
      })
    }
};

InstanceType: InstanceType = {
  () => InstanceType::Plain,
  "derive" => InstanceType::Derive,
  "derive" "newtype" => InstanceType::DeriveNewtype,
};

TypeClassConstraints: Vec<Type> = {
  <Located<Constraint>> => vec![<>],
  "(" <SepBy<Located<Constraint>, ",">> ")"
};

TypeParameter: TypeParameter = {
  <name:LowerIdent> => (name, None),
  "(" <name:LowerIdent> "::" <type_:Type> ")" => (name, Some(type_))
};

ValueDeclaration: ValueDeclaration = {
  <ident:LowerIdent> <params:AsPat<Located<PrimaryExpr<"full">>>*> "=" <expr:Expr> =>
    ValueDeclaration{ident, params, expr: vec![GuardedExpr{guards: vec![], expr}]},
}

TypeDeclaration: TypeDeclarationData = {
  <ident:LowerIdent> "::" <type_:Type> => TypeDeclarationData::new(ident,type_)
}

pub Expr = ExprV<"full">;

ExprV<Variant> = Located<ExprKind<Variant>>;

ExprKind<Variant>: ExprKind = ExprN1<Variant>;

// if, let, etc.
ExprN1<Variant>: ExprKind = {
  Expr0<Variant>,
  LambdaLike if Variant == "full",
  <f:Located<Expr2<Variant>>> <x:Located<LambdaLike>> if Variant == "full" => super::normalize_app(f, x),
};

LambdaLike: ExprKind = {
  "\\" <params:AsPat<Located<PrimaryExpr<"full">>>+> "->" <body:Box<Expr>>
    => ExprKind::Lam(params, body),
  "if" <cond:Box<Expr>> "then" <then_:Box<Expr>> "else" <else_:Box<Expr>>
    => ExprKind::If{ cond, then_, else_ },
  "let" <decls:LayoutBlock<LetDeclaration>> "in" <body:Box<Expr>>
    => ExprKind::Let{ decls, body },
  "case" <expr:Box<Expr>> "of" <branches:LayoutBlock<CaseBranch>>
    => ExprKind::Case{ expr, branches }
};

// Typed
Expr0<Variant> = Expr1<Variant>;

// Infix
Expr1<Variant>: ExprKind = {
  Expr2<Variant>,
  <expr:Box<Located<Expr2<Variant>>>> "::" <type_:Type> if Variant == "full" => ExprKind::Typed(expr, type_),
  <first:Box<Located<Expr2<Variant>>>> <rest:( <Operator> <Located<Expr2<"full">>> )+>
    => ExprKind::Infix(first, rest),
  <start:@L> <first:Box<Located<Expr2<Variant>>>> <rest:( <Operator> <Located<Expr2<"full">>> )+> <end:@R> "::" <type_:Type>
    if Variant == "full" => ExprKind::Typed(Box::new(Located(SourceSpan{start, end}, ExprKind::Infix(first, rest))), type_),
  <first:Box<Located<Expr2<Variant>>>> <mut rest:( <Operator> <Located<Expr2<"full">>> )*> <last:( <Operator> <Located<LambdaLike>> )>
    if Variant == "full" => {
      rest.push(last);
      ExprKind::Infix(first, rest)
    },
};

Operator: Symbol = {
  operator => Symbol::new(<>),
  "<=" => Symbol::new("<=".into()),
  "=>" => Symbol::new("=>".into()),
};

// Backtick
Expr2<Variant> = Expr3<Variant>;

// Negate
Expr3<Variant> = Expr4<Variant>;

// Apply
Expr4<Variant>: ExprKind = {
  Expr5<Variant>,
  <f:Located<Expr5<Variant>>> <args:Located<Expr5<"full">>+>
    => super::apply_record_updates(f, args),
};

// Was if, let etc. - moved up
Expr5<Variant> = Expr6<Variant>;

// Record update - handled elsewhere
Expr6<Variant> = Expr7<Variant>;

// Accessor
Expr7<Variant>: ExprKind = {
  PrimaryExpr<Variant>,
  <obj:Box<Located<Expr7<Variant>>>> "." <label:Label> => ExprKind::Accessor(obj, label),
};

PrimaryExpr<Variant>: ExprKind = {
  Literal<Expr, RecordShortcutExpr> => ExprKind::Literal(<>),
  "{" <SepBy1<RecordUpdate, ",">> "}" => ExprKind::RecordUpdateSuffix(<>),
  LowerQualifiedIdent if Variant != "let_pat" => ExprKind::Var(<>),
  <name:LowerIdent> "@" <expr:Box<Located<PrimaryExpr<"full">>>> => ExprKind::NamedPat(name, expr),
  UpperQualifiedIdent => ExprKind::DataConstructor(<>),
  "(" <ExprKind<"full">> ")" => <>,
  "_" => ExprKind::Wildcard,
  "do" <LayoutBlock<DoItem>> => ExprKind::Do(<>),
}

RecordUpdate: (Symbol, Expr) = {
  <label:Label> "=" <expr:Expr> => (label, expr)
};

CaseBranch: CaseBranch = {
  <pat:AsPat<ExprV<"case_pat">>> "->" <expr:Expr> => CaseBranch{ pat, expr }
};

DoItem: DoItem = {
  "let" <LayoutBlock<LetDeclaration>> => DoItem::Let(<>),
  <Expr> => DoItem::Expr(<>),
  <pat:AsPat<Expr>> "<-" <expr:Expr> => DoItem::Bind(pat, expr),
};

AsPat<E>: Pat = {
  <E> =>? {
    super::expr_to_pat(<>)
      .map_err(|err| ParseError::User {
        // TODO: make it not a lexer error
        error: lexer::Error(err)
      })
  }
};

Literal<T, RecordShortcut>: Literal<T> = {
  int => Literal::Integer(<>),
  // float => Literal::Float(<>),
  string => Literal::String(<>),
  char => Literal::Char(<>),
  "true" => Literal::Boolean(true),
  "false" => Literal::Boolean(false),
  "[" <SepBy<T, ",">> "]" => Literal::Array(<>),
  "{" <SepBy<RecordField<T, RecordShortcut>, ",">> "}" => Literal::Object(<>),
}

RecordField<T, RecordShortcut>: (Symbol, T) = {
  <label:Label> ":" <expr:T> => (label, expr),
  RecordShortcut
};

RecordShortcutExpr: (Symbol, Expr) = {
  // Note: string literal labels not allowed here, because they may not be a valid variable name
  <start:@L> <label:lower_ident> <end:@R> => {
    let label = Symbol::new(label);
    (
      label.clone(),
      Located(SourceSpan{start, end}, ExprKind::Var(QualifiedName(label)))
    )
  }
};

// TODO: extract the comments
Commented<T>: Commented<T> = {
  <v:T> => Commented(vec![], v)
};

SepBy<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

SepBy1<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

OptionalList<T, X>: Vec<T> = {
  X? => <>.unwrap_or_else(|| vec![]),
};

////////////////////////////////////////////////////////////////////////////////
// Type
////////////////////////////////////////////////////////////////////////////////

pub Type = Located<Type1>;

Type1: TypeKind = {
  // TODO: At first I put the forall in AtomicType, but it resulted in parse conflicts.
  // Here it seems to work. I have no idea why.
  "forall" <vars:OneOrMore<ForallVar>> "." <body:Type> =>
    TypeKind::ForAll{vars,body:Box::new(body),skolem_scope:None},
  <constraint:Located<TypeApp>> "=>" <body:Type> =>
    TypeKind::Constrained{constraint:Box::new(constraint),body:Box::new(body)},
  <arg:Located<TypeApp>> "->" <result:Type> =>
    TypeKind::FunctionType(Box::new(arg), Box::new(result)),
  TypeApp
}

Constraint: TypeKind = {
  <l:Located<Constraint>> <r:Located<AtomicType>> => TypeKind::TypeApp(Box::new(l), Box::new(r)),
  TypeConstructor
};

TypeApp: TypeKind = {
  <l:Located<TypeApp>> <r:Located<AtomicType>> => TypeKind::TypeApp(Box::new(l), Box::new(r)),
  AtomicType
};

TypeConstructor: TypeKind = {
  UpperQualifiedIdent => TypeKind::TypeConstructor(<>),
};

AtomicType: TypeKind = {
  LowerIdent => TypeKind::Var(<>),
  "(" <TypeOperator> ")" => TypeKind::Var(<>),
  string=>TypeKind::TypeLevelString(<>),
  int=>TypeKind::TypeLevelInt(<>.into()),
  "_" => TypeKind::Wildcard(WildcardKind::Unnamed),
  // TODO: hole

  TypeConstructor,
  "(" <fields:SepBy<RowField, ",">> <rest:RowRest?> ")" => TypeKind::Row{fields,rest},
  <record_start:@L> "{" <record_end:@R>
  <row_start:@L> <fields:SepBy<RowField, ",">> <rest:RowRest?> <row_end:@R> "}" =>
    TypeKind::TypeApp(
      Box::new(
        Located(SourceSpan{start: record_start, end: record_end}, 
          TypeKind::TypeConstructor(QualifiedName(Symbol::new("Prim.Record".to_string()))))),
      Box::new(
        Located(SourceSpan{start: row_start, end: row_end}, 
          TypeKind::Row{fields,rest}))
    ),
  "(" <v:Type> ")" => TypeKind::Parens(Box::new(v)),
};

RowField: (Symbol, Type) = {
  <label:Label> "::" <ty:Type> => (label, ty)
}

RowRest: Box<Type> = {
  "|" <ty:Type> => Box::new(ty)
}

/// A record field label
Label: Symbol = {
  LowerIdent,
  string => Symbol::new(<>),
};

ForallVar: (Symbol, Option<Box<Type>>) = {
  <name:LowerIdent> => (name, None),
  "(" <name:LowerIdent> "::" <kind:Type> ")" => (name, Some(Box::new(kind))),
};

OneOrMore<T>: Vec<T> = {
  <xs:T*> <x:T> => {
    let mut xs = xs;
    xs.push(x);
    xs
  }
}

Box<T>: Box<T> = {
  <T> => Box::new(<>)
}

extern {
  type Location = usize;
  type Error = lexer::Error;

  enum Token {
    int => Token::IntegerLiteral(<i32>),
    string => Token::StringLiteral(<String>),
    char => Token::CharLiteral(<char>),
    lower_ident => Token::LowerIdentifier(<String>),
    lower_qualified_ident => Token::QualifiedLowerIdentifier(<String>),
    upper_ident => Token::UpperIdentifier(<String>),
    upper_qualified_ident => Token::QualifiedUpperIdentifier(<String>),

    // Layout
    LayoutStart => Token::LayoutStart,
    LayoutSep => Token::LayoutSep,
    LayoutEnd => Token::LayoutEnd,

    // Operators
    "(" => Token::LeftParen,
    ")" => Token::RightParen,
    "{" => Token::LeftBrace,
    "}" => Token::RightBrace,
    "[" => Token::LeftBracket,
    "]" => Token::RightBracket,
    "`" => Token::Backtick,
    "=" => Token::Equal,
    "|" => Token::Pipe,
    "," => Token::Comma,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "." => Token::Dot,
    "\\" => Token::Backslash,
    "@" => Token::At,

    "->" => Token::Arrow,
    "=>" => Token::FatArrow,
    "<=" => Token::LeftFatArrow,
    "::" => Token::TypeOf,
    "<-" => Token::Bind,
    ".." => Token::DotDot,

    operator => Token::Operator(<String>),

    // Keywords
    "if" => Token::If,
    "then" => Token::Then,
    "else" => Token::Else,
    "ado" => Token::Ado,
    "do" => Token::Do,
    "case" => Token::Case,
    "of" => Token::Of,
    "let" => Token::Let,
    "in" => Token::In,
    "where" => Token::Where,
    "instance" => Token::Instance,
    "module" => Token::Module,
    "import" => Token::Import,
    "forall" => Token::Forall,
    "true" => Token::True,
    "false" => Token::False,
    "class" => Token::Class,
    "type" => Token::Type,
    "as" => Token::As,
    "hiding" => Token::Hiding,
    "foreign" => Token::Foreign,
    "derive" => Token::Derive,
    "newtype" => Token::Newtype,
    "data" => Token::Data,
    "_" => Token::Wildcard,
  }
}
