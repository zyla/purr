use crate::token::Token;
use crate::lexer;
use crate::ast::*;
use crate::symbol::*;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, &'static str>>);

pub Module: Module = Located<Commented<ModuleInner>>;

pub ModuleInner: ModuleInner = {
  "module" <name:Ident> "where" <declarations: MaybeLayoutBlock<Declaration>>
      => ModuleInner { name, exports: None, declarations }
};

Ident: Symbol = {
  ident => Symbol(<>)
};

Located<T>: Located<T> = {
  <start:@L> <v:T> <end:@L> => Located(SourceSpan{start, end}, v)
};

MaybeLayoutBlock<T>: Vec<T> = {
  LayoutBlock<T>? => <>.unwrap_or_else(|| vec![])
}

LayoutBlock<T>: Vec<T> = {
  LayoutStart <v:SepBy<T, LayoutSep>> LayoutEnd => v
}

Declaration: Declaration = Located<Commented<DeclarationKind>>;

DeclarationKind: DeclarationKind = {
  ValueDeclaration => DeclarationKind::ValueDeclaration(<>)
}

ValueDeclaration: ValueDeclaration = {
  <ident:Ident> "=" <expr:Expr> => ValueDeclaration{ident, expr: vec![GuardedExpr{guards: vec![], expr}]}
}

Expr: Expr = Located<ExprKind>;

ExprKind: ExprKind = {
  int => ExprKind::Literal(Literal::Integer(<>))
}

// TODO: extract the comments
Commented<T>: Commented<T> = {
  <v:T> => Commented(vec![], v)
};

SepBy<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

extern {
  type Location = usize;
  type Error = lexer::Error;

  enum Token {
    int => Token::IntegerLiteral(<i32>),
    string => Token::StringLiteral(<String>),
    char => Token::CharLiteral(<char>),
    ident => Token::Identifier(<String>),

    // Layout
    LayoutStart => Token::LayoutStart,
    LayoutSep => Token::LayoutSep,
    LayoutEnd => Token::LayoutEnd,

    // Operators
    "(" => Token::LeftParen,
    ")" => Token::RightParen,
    "{" => Token::LeftBrace,
    "}" => Token::RightBrace,
    "[" => Token::LeftBracket,
    "]" => Token::RightBracket,
    "`" => Token::Backtick,
    "=" => Token::Equal,
    "|" => Token::Pipe,
    "," => Token::Comma,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "." => Token::Dot,
    "\\" => Token::Backslash,

    "->" => Token::Arrow,
    "=>" => Token::FatArrow,
    "::" => Token::TypeOf,
    "<-" => Token::Bind,

    operator => Token::Operator(<String>),

    // Keywords
    "if" => Token::If,
    "then" => Token::Then,
    "else" => Token::Else,
    "ado" => Token::Ado,
    "do" => Token::Do,
    "case" => Token::Case,
    "of" => Token::Of,
    "let" => Token::Let,
    "in" => Token::In,
    "where" => Token::Where,
    "instance" => Token::Instance,
    "module" => Token::Module,
    "import" => Token::Import,
  }
}
