use crate::token::Token;
use crate::lexer;
use crate::ast::*;
use crate::symbol::*;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, &'static str>>);

pub Module: Module = Located<Commented<ModuleInner>>;

pub ModuleInner: ModuleInner = {
  // FIXME: name should be qualified
  "module" <name:UpperIdent> "where" <declarations: MaybeLayoutBlock<Declaration>>
      => ModuleInner { name, exports: None, declarations }
};

LowerIdent: Symbol = {
  lower_ident => Symbol(<>)
};

UpperIdent: Symbol = {
  upper_ident => Symbol(<>)
};

Located<T>: Located<T> = {
  <start:@L> <v:T> <end:@L> => Located(SourceSpan{start, end}, v)
};

MaybeLayoutBlock<T>: Vec<T> = {
  LayoutBlock<T>? => <>.unwrap_or_else(|| vec![])
}

LayoutBlock<T>: Vec<T> = {
  LayoutStart <v:SepBy<T, LayoutSep>> LayoutEnd => v
}

Declaration: Declaration = Located<Commented<DeclarationKind>>;

DeclarationKind: DeclarationKind = {
  ValueDeclaration => DeclarationKind::ValueDeclaration(<>)
}

ValueDeclaration: ValueDeclaration = {
  <ident:LowerIdent> "=" <expr:Expr> => ValueDeclaration{ident, expr: vec![GuardedExpr{guards: vec![], expr}]}
}

Expr: Expr = Located<ExprKind>;

ExprKind: ExprKind = {
  int => ExprKind::Literal(Literal::Integer(<>))
}

// TODO: extract the comments
Commented<T>: Commented<T> = {
  <v:T> => Commented(vec![], v)
};

SepBy<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

////////////////////////////////////////////////////////////////////////////////
// Type
////////////////////////////////////////////////////////////////////////////////

pub Type = Located<Type1>;

Type1: TypeKind = {
  // TODO: At first I put the forall in AtomicType, but it resulted in parse conflicts.
  // Here it seems to work. I have no idea why.
  "forall" <vars:OneOrMore<ForallVar>> "." <body:Type> =>
    TypeKind::ForAll{vars,body:Box::new(body),skolem_scope:None},
  TypeApp
}

TypeApp: TypeKind = {
  <l:Located<TypeApp>> <r:Located<AtomicType>> => TypeKind::TypeApp(Box::new(l), Box::new(r)),
  AtomicType
};

AtomicType: TypeKind = {
  LowerIdent => TypeKind::Var(<>),
  string=>TypeKind::TypeLevelString(<>),
  int=>TypeKind::TypeLevelInt(<>.into()),
  "_" => TypeKind::Wildcard(WildcardKind::Unnamed),
  // TODO: hole

  UpperIdent => TypeKind::TypeConstructor(QualifiedName(<>)), // TODO: qualified
  "(" <v:Type> ")" =>TypeKind::Parens(Box::new(v)),
};

ForallVar: (Symbol, Option<Box<Type>>) = {
  <name:LowerIdent> => (name, None),
  "(" <name:LowerIdent> "::" <kind:Type> ")" => (name, Some(Box::new(kind))),
};

OneOrMore<T>: Vec<T> = {
  <xs:T*> <x:T> => {
    let mut xs = xs;
    xs.push(x);
    xs
  }
}

extern {
  type Location = usize;
  type Error = lexer::Error;

  enum Token {
    int => Token::IntegerLiteral(<i32>),
    string => Token::StringLiteral(<String>),
    char => Token::CharLiteral(<char>),
    lower_ident => Token::LowerIdentifier(<String>),
    upper_ident => Token::UpperIdentifier(<String>),

    // Layout
    LayoutStart => Token::LayoutStart,
    LayoutSep => Token::LayoutSep,
    LayoutEnd => Token::LayoutEnd,

    // Operators
    "(" => Token::LeftParen,
    ")" => Token::RightParen,
    "{" => Token::LeftBrace,
    "}" => Token::RightBrace,
    "[" => Token::LeftBracket,
    "]" => Token::RightBracket,
    "`" => Token::Backtick,
    "=" => Token::Equal,
    "|" => Token::Pipe,
    "," => Token::Comma,
    ":" => Token::Colon,
    ";" => Token::Semicolon,
    "." => Token::Dot,
    "\\" => Token::Backslash,

    "->" => Token::Arrow,
    "=>" => Token::FatArrow,
    "::" => Token::TypeOf,
    "<-" => Token::Bind,

    operator => Token::Operator(<String>),

    // Keywords
    "if" => Token::If,
    "then" => Token::Then,
    "else" => Token::Else,
    "ado" => Token::Ado,
    "do" => Token::Do,
    "case" => Token::Case,
    "of" => Token::Of,
    "let" => Token::Let,
    "in" => Token::In,
    "where" => Token::Where,
    "instance" => Token::Instance,
    "module" => Token::Module,
    "import" => Token::Import,
    "forall" => Token::Forall,
    "_" => Token::Wildcard,
  }
}
